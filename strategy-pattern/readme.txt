策略模式，定义了算法簇，分别封装起来，他们直接可以相互替换，使算法的变化独立于使用算法的客人

软件开发不变的就是变化
找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起（设计原则）
变化封装了，变化影响小了，系统更具弹性了
针对接口变程，而不是针对实现编程
多用组合，少用继承，"有一个"比"是一个"更好


##demo
鸭子父类
    实现了 quack() swim()
    声明了 display()
绿头鸭子类
    自己实现了 display()
    继承了 quack() swim()
红头鸭子类
    自己实现了 display()
    继承了 quack() swim()

##scenario 1
现在想增加 飞行 能力

do
    在Duck中增加 fly(),顺理成章的Duck子类都拥有了 飞行 能力
prb
    暂时没有

##scienraio 2
现在我们需要实现另一个"鸭子"，橡皮鸭

do
    1.我们新建RubberDuck同时继承Duck
prb
    1.橡皮鸭不能飞
    2.橡皮鸭叫声不是Ga Ga，是Zhi Zhi
do
    1.重新覆盖fly()，实现不能飞
    2.重新覆盖quack()，实现Zhi Zhi叫

我们又新加了另一类"鸭子"诱饵鸭，不能飞、不能叫
do
    1.新建DecoyDuck类，继承Duck
    2.重新覆盖fly()，实现不能飞
    3.重新覆盖quack()，实现不能叫
prb
    1.RubberDuck和DecoyDuck的fly()方法重复，不能复用
    2.除了display我们还要重写quack()

bp
    1.继承会强制子类拥有自己所有的方法和属性
    2.当子类需要覆盖父类实现，会造成大量代码重复，复用较低
    3.新增子类事，需要考虑父类赋予的所有方法，是否需要覆盖实现，且问题在于这是 "不被提示" "主动了解" "容易忽略"

##scienraio 3
考虑到继承的问题，无数的子类都要考虑fly和quack的实现，是否能用接口？
让能飞的实现fly接口，让能叫的实现quack接口

do
    1.删除Duck的超类方法 fly() 和 quack()
    2.建立接口Flyable()和Quackable()
    3.让能飞的实现Flyable，让能叫的实现Quackable
prb
    1.红头鸭和绿头鸭 重复写了fly()
bp
    1.使用接口，基于实现，确实解决了被动继承能力，不断覆盖实现的问题
    2.使用者 直接 实现接口，会书写大量重复的实现代码，复用很低
    3.我们需要把变化的地方，也就是fly()quack()提出来

##scenario 4
分离变化代码和不变代码，使用方使用接口，实现方独立出去，且是一组具体实现

do
    1.建立接口FlyBehavior,QuackBehavior
    2.独立实现两个behavior，分成两组
    3.鸭子依赖behavior接口，不能依赖具体实现
prb
    1.在鸭子具体实现中，构造方法，依赖了具体的behavior实现方式
bp
